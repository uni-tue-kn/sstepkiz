import { Injectable, ɵɵdefineInjectable, EventEmitter, ɵɵinject, InjectionToken, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import { from, throwError, fromEvent } from 'rxjs';
import { filter, mergeMap, map, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/platform/browser.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BrowserWebBluetooth {
    constructor() {
        this.ble = navigator.bluetooth;
        if (!this.ble) {
            throw new Error('Your browser does not support Smart Bluetooth. See http://caniuse.com/#search=Bluetooth for more details.');
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    requestDevice(options) {
        return this.ble.requestDevice(options);
    }
}
BrowserWebBluetooth.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BrowserWebBluetooth.ctorParameters = () => [];
if (false) {
    /**
     * @type {?}
     * @private
     */
    BrowserWebBluetooth.prototype.ble;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/platform/server.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ServerWebBluetooth {
    /**
     * @return {?}
     */
    static instance() {
        // mocked object for now
        return {};
    }
}
ServerWebBluetooth.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/logger.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Logger() { }
if (false) {
    /**
     * @param {?} args
     * @return {?}
     */
    Logger.prototype.log = function (args) { };
    /**
     * @param {?} args
     * @return {?}
     */
    Logger.prototype.error = function (args) { };
    /**
     * @param {?} args
     * @return {?}
     */
    Logger.prototype.warn = function (args) { };
}
class ConsoleLoggerService {
    /**
     * @param {...?} args
     * @return {?}
     */
    log(...args) {
        console.log.apply(console, args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    error(...args) {
        console.error.apply(console, args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    warn(...args) {
        console.warn.apply(console, args);
    }
}
ConsoleLoggerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ConsoleLoggerService.ɵprov = ɵɵdefineInjectable({ factory: function ConsoleLoggerService_Factory() { return new ConsoleLoggerService(); }, token: ConsoleLoggerService, providedIn: "root" });
class NoLoggerService {
    /**
     * @param {...?} args
     * @return {?}
     */
    log(...args) { }
    /**
     * @param {...?} args
     * @return {?}
     */
    error(...args) { }
    /**
     * @param {...?} args
     * @return {?}
     */
    warn(...args) { }
}
NoLoggerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NoLoggerService.ɵprov = ɵɵdefineInjectable({ factory: function NoLoggerService_Factory() { return new NoLoggerService(); }, token: NoLoggerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/bluetooth.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BluetoothCore {
    /**
     * @param {?} webBle
     * @param {?} console
     */
    constructor(webBle, console) {
        this.webBle = webBle;
        this.console = console;
        this.device$ = new EventEmitter();
        this.gatt$ = new EventEmitter();
        this.characteristicValueChanges$ = new EventEmitter();
        this.gattServer = null;
    }
    /**
     * @return {?}
     */
    getDevice$() {
        return this.device$;
    }
    /**
     * @return {?}
     */
    getGATT$() {
        return this.gatt$;
    }
    /**
     * @return {?}
     */
    streamValues$() {
        return this.characteristicValueChanges$.pipe(filter((/**
         * @param {?} value
         * @return {?}
         */
        value => value && value.byteLength > 0)));
    }
    /**
     * Run the discovery process and read the value form the provided service and characteristic
     * @param {?} options the ReadValueOptions
     * @return {?}
     */
    value(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.console.log('[BLE::Info] Reading value with options %o', options);
            if (typeof options.acceptAllDevices === 'undefined') {
                options.acceptAllDevices = true;
            }
            if (typeof options.optionalServices === 'undefined') {
                options.optionalServices = [options.service];
            }
            else {
                options.optionalServices = [...options.optionalServices];
            }
            this.console.log('[BLE::Info] Reading value with options %o', options);
            try {
                /** @type {?} */
                const device = (/** @type {?} */ (yield this.discover({
                    acceptAllDevices: options.acceptAllDevices,
                    optionalServices: options.optionalServices
                })));
                this.console.log('[BLE::Info] Device info %o', device);
                /** @type {?} */
                const gatt = yield this.connectDevice(device);
                this.console.log('[BLE::Info] GATT info %o', gatt);
                /** @type {?} */
                const primaryService = (/** @type {?} */ (yield this.getPrimaryService(gatt, options.service)));
                this.console.log('[BLE::Info] Primary Service info %o', primaryService);
                /** @type {?} */
                const characteristic = (/** @type {?} */ (yield this.getCharacteristic(primaryService, options.characteristic)));
                this.console.log('[BLE::Info] Characteristic info %o', characteristic);
                /** @type {?} */
                const value = yield characteristic.readValue();
                this.console.log('[BLE::Info] Value info %o', value);
                return value;
            }
            catch (error) {
                throw new Error(error);
            }
        });
    }
    /**
     * @param {?} options
     * @return {?}
     */
    value$(options) {
        return from(this.value(options));
    }
    /**
     * Run the discovery process.
     *
     * @param {?=} options
     * @return {?} The GATT server for the chosen device
     */
    discover(options = (/** @type {?} */ ({}))) {
        return __awaiter(this, void 0, void 0, function* () {
            options.optionalServices = options.optionalServices || ['generic_access'];
            this.console.log('[BLE::Info] Requesting devices with options %o', options);
            /** @type {?} */
            let device = null;
            try {
                device = yield this.webBle.requestDevice(options);
                device.addEventListener('gattserverdisconnected', this.onDeviceDisconnected.bind(this));
                if (device) {
                    this.device$.emit(device);
                }
                else {
                    this.device$.error(`[BLE::Error] Can not get the Bluetooth Remote GATT Server. Abort.`);
                }
            }
            catch (error) {
                this.console.error(error);
            }
            return device;
        });
    }
    /**
     * This handler will trigger when the client disconnets from the server.
     *
     * @param {?} event The onDeviceDisconnected event
     * @return {?}
     */
    onDeviceDisconnected(event) {
        /** @type {?} */
        const disconnectedDevice = (/** @type {?} */ (event.target));
        this.console.log('[BLE::Info] disconnected device %o', disconnectedDevice);
        this.device$.emit(null);
    }
    /**
     * Run the discovery process.
     *
     * @param {?=} options
     * @return {?} Emites the value of the requested service read from the device
     */
    discover$(options) {
        return from(this.discover(options)).pipe(mergeMap((/**
         * @param {?} device
         * @return {?}
         */
        (device) => this.connectDevice$(device))));
    }
    /**
     * Connect to current device.
     *
     * @param {?} device
     * @return {?} Emites the gatt server instance of the requested device
     */
    connectDevice(device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (device) {
                this.console.log('[BLE::Info] Connecting to Bluetooth Remote GATT Server of %o', device);
                try {
                    /** @type {?} */
                    const gattServer = yield device.gatt.connect();
                    this.gattServer = gattServer;
                    this.gatt$.emit(gattServer);
                    return gattServer;
                }
                catch (error) {
                    // probably the user has canceled the discovery
                    Promise.reject(`${error.message}`);
                    this.gatt$.error(`${error.message}`);
                }
            }
            else {
                this.console.error('[BLE::Error] Was not able to connect to Bluetooth Remote GATT Server');
                this.gatt$.error(null);
            }
        });
    }
    /**
     * Connect to current device.
     *
     * @param {?} device
     * @return {?} Emites the gatt server instance of the requested device
     */
    connectDevice$(device) {
        return from(this.connectDevice(device));
    }
    /**
     * Disconnect the current connected device
     * @return {?}
     */
    disconnectDevice() {
        if (!this.gattServer) {
            return;
        }
        this.console.log('[BLE::Info] Disconnecting from Bluetooth Device %o', this.gattServer);
        if (this.gattServer.connected) {
            this.gattServer.disconnect();
        }
        else {
            this.console.log('[BLE::Info] Bluetooth device is already disconnected');
        }
    }
    /**
     * Requests the primary service.
     *
     * @param {?} gatt The BluetoothRemoteGATTServer sever
     * @param {?} service The UUID of the primary service
     * @return {?} The remote service (as a Promise)
     */
    getPrimaryService(gatt, service) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /** @type {?} */
                const remoteService = yield gatt.getPrimaryService(service);
                return yield Promise.resolve(remoteService);
            }
            catch (error) {
                return yield Promise.reject(`${error.message} (${service})`);
            }
        });
    }
    /**
     * Requests the primary service.
     *
     * @param {?} gatt The BluetoothRemoteGATTServer sever
     * @param {?} service The UUID of the primary service
     * @return {?} The remote service (as an observable).
     */
    getPrimaryService$(gatt, service) {
        this.console.log('[BLE::Info] Getting primary service "%s" (if available) of %o', service, gatt);
        if (gatt) {
            return from(this.getPrimaryService(gatt, service));
        }
        else {
            return throwError(new Error('[BLE::Error] Was not able to connect to the Bluetooth Remote GATT Server'));
        }
    }
    /**
     * Requests a characteristic from the primary service.
     *
     * @param {?} primaryService The primary service.
     * @param {?} characteristic The characteristic's UUID.
     * @return {?} The characteristic description (as a Promise).
     */
    getCharacteristic(primaryService, characteristic) {
        return __awaiter(this, void 0, void 0, function* () {
            this.console.log('[BLE::Info] Getting Characteristic "%s" of %o', characteristic, primaryService);
            try {
                /** @type {?} */
                const char = yield primaryService.getCharacteristic(characteristic);
                // listen for characteristic value changes
                if (char.properties.notify) {
                    char.startNotifications().then((/**
                     * @param {?} _
                     * @return {?}
                     */
                    _ => {
                        this.console.log('[BLE::Info] Starting notifications of "%s"', characteristic);
                        char.addEventListener('characteristicvaluechanged', this.onCharacteristicChanged.bind(this));
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    (error) => {
                        Promise.reject(`${error.message} (${characteristic})`);
                    }));
                }
                else {
                    char.addEventListener('characteristicvaluechanged', this.onCharacteristicChanged.bind(this));
                }
                return char;
            }
            catch (rejectionError) {
                Promise.reject(`${rejectionError.message} (${characteristic})`);
            }
        });
    }
    /**
     * Requests a characteristic from the primary service.
     *
     * @param {?} primaryService The primary service.
     * @param {?} characteristic The characteristic's UUID.
     * @return {?} The characteristic description (as a Observable).
     */
    getCharacteristic$(primaryService, characteristic) {
        this.console.log('[BLE::Info] Getting Characteristic "%s" of %o', characteristic, primaryService);
        return from(this.getCharacteristic(primaryService, characteristic));
    }
    /**
     * Sets the characteristic's state.
     *
     * @param {?} service The parent service of the characteristic.
     * @param {?} characteristic The requested characteristic
     * @param {?} state An ArrayBuffer containing the value of the characteristic.
     * @return {?} The primary service (useful for chaining).
     */
    setCharacteristicState(service, characteristic, state) {
        /** @type {?} */
        const primaryService = this.getPrimaryService$(this.gattServer, service);
        primaryService
            // tslint:disable-next-line: variable-name
            .pipe(mergeMap((/**
         * @param {?} _primaryService
         * @return {?}
         */
        (_primaryService) => this.getCharacteristic$(_primaryService, characteristic))))
            // tslint:disable-next-line: no-shadowed-variable
            .subscribe((/**
         * @param {?} characteristic
         * @return {?}
         */
        (characteristic) => this.writeValue$(characteristic, state)));
        return primaryService;
    }
    /**
     * Enables the specified characteristic of a given service.
     *
     * @param {?} service The parent service of the characteristic.
     * @param {?} characteristic The requested characteristic
     * @param {?=} state
     * @return {?} The primary service (useful for chaining).
     */
    enableCharacteristic(service, characteristic, state) {
        state = state || new Uint8Array([1]);
        return this.setCharacteristicState(service, characteristic, state);
    }
    /**
     * Disables the specified characteristic of a given service.
     *
     * @param {?} service The parent service of the characteristic.
     * @param {?} characteristic The requested characteristic.
     * @param {?=} state
     * @return {?} The primary service (useful for chaining).
     */
    disbaleCharacteristic(service, characteristic, state) {
        state = state || new Uint8Array([0]);
        return this.setCharacteristicState(service, characteristic, state);
    }
    /**
     * Dispatches new values emitted by a characteristic.
     *
     * @param {?} event the distpatched event.
     * @return {?}
     */
    onCharacteristicChanged(event) {
        this.console.log('[BLE::Info] Dispatching new characteristic value %o', event);
        /** @type {?} */
        const value = ((/** @type {?} */ (event.target))).value;
        this.characteristicValueChanges$.emit(value);
    }
    /**
     * Reads a value from the characteristics, as a DataView.
     *
     * @param {?} characteristic The requested characteristic.
     * @return {?} the DataView value (as an Observable).
     */
    readValue$(characteristic) {
        this.console.log('[BLE::Info] Reading Characteristic %o', characteristic);
        return from(characteristic
            .readValue()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        (data) => Promise.resolve(data)), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => Promise.reject(`${error.message}`))));
    }
    /**
     * Writes a value into the specified characteristic.
     *
     * @param {?} characteristic The requested characteristic.
     * @param {?} value The value to be written (as an ArrayBuffer or Uint8Array).
     * @return {?} an void Observable.
     */
    writeValue$(characteristic, value) {
        this.console.log('[BLE::Info] Writing Characteristic %o', characteristic);
        return from(characteristic.writeValue(value).then((/**
         * @param {?} _
         * @return {?}
         */
        _ => Promise.resolve()), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => Promise.reject(`${error.message}`))));
    }
    /**
     * A stream of DataView values emitted by the specified characteristic.
     *
     * @param {?} characteristic The characteristic which value you want to observe
     * @return {?} The stream of DataView values.
     */
    observeValue$(characteristic) {
        characteristic.startNotifications();
        /** @type {?} */
        const disconnected = fromEvent(characteristic.service.device, 'gattserverdisconnected');
        return fromEvent(characteristic, 'characteristicvaluechanged')
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        (event) => (/** @type {?} */ (((/** @type {?} */ (event.target))).value)))), takeUntil(disconnected));
    }
    /**
     * A utility method to convert LE to an unsigned 16-bit integer values.
     *
     * @param {?} data The DataView binary data.
     * @param {?} byteOffset The offset, in byte, from the start of the view where to read the data.
     * @return {?} An unsigned 16-bit integer number.
     */
    littleEndianToUint16(data, byteOffset) {
        // tslint:disable-next-line:no-bitwise
        return (this.littleEndianToUint8(data, byteOffset + 1) << 8) + this.littleEndianToUint8(data, byteOffset);
    }
    /**
     * A utility method to convert LE to an unsigned 8-bit integer values.
     *
     * @param {?} data The DataView binary data.
     * @param {?} byteOffset The offset, in byte, from the start of the view where to read the data.
     * @return {?} An unsigned 8-bit integer number.
     */
    littleEndianToUint8(data, byteOffset) {
        return data.getUint8(byteOffset);
    }
    /**
     * Sends random data (for testing purposes only).
     *
     * @param {?=} fakeValue
     * @return {?} Random unsigned 8-bit integer values.
     */
    fakeNext(fakeValue) {
        if (fakeValue === undefined) {
            fakeValue = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const dv = new DataView(new ArrayBuffer(8));
                // tslint:disable-next-line:no-bitwise
                dv.setUint8(0, (Math.random() * 110) | 0);
                return dv;
            });
        }
        this.characteristicValueChanges$.emit(fakeValue());
    }
}
BluetoothCore.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BluetoothCore.ctorParameters = () => [
    { type: BrowserWebBluetooth },
    { type: ConsoleLoggerService }
];
/** @nocollapse */ BluetoothCore.ɵprov = ɵɵdefineInjectable({ factory: function BluetoothCore_Factory() { return new BluetoothCore(ɵɵinject(BrowserWebBluetooth), ɵɵinject(ConsoleLoggerService)); }, token: BluetoothCore, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.device$;
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.gatt$;
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.characteristicValueChanges$;
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.gattServer;
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.webBle;
    /**
     * @type {?}
     * @private
     */
    BluetoothCore.prototype.console;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/bluetooth.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function AWBOptions() { }
if (false) {
    /** @type {?|undefined} */
    AWBOptions.prototype.enableTracing;
}
/**
 * @return {?}
 */
function browserWebBluetooth() {
    return new BrowserWebBluetooth();
}
/**
 * @param {?} options
 * @return {?}
 */
function consoleLoggerServiceConfig(options) {
    if (options && options.enableTracing) {
        return new ConsoleLoggerService();
    }
    else {
        return new NoLoggerService();
    }
}
/**
 * @return {?}
 */
function makeMeTokenInjector() {
    return new InjectionToken('AWBOptions');
}
class WebBluetoothModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: WebBluetoothModule,
            providers: [
                BluetoothCore,
                {
                    provide: BrowserWebBluetooth,
                    useFactory: browserWebBluetooth
                },
                {
                    provide: makeMeTokenInjector,
                    useValue: options
                },
                {
                    provide: ConsoleLoggerService,
                    useFactory: consoleLoggerServiceConfig,
                    deps: [makeMeTokenInjector]
                }
            ]
        };
    }
}
WebBluetoothModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lang/uuids/ti-sensortag2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// http://processors.wiki.ti.com/images/a/a8/BLE_SensorTag_GATT_Server.pdf
// prettier-ignore
/** @type {?} */
const TiTag = {
    DEVICE_INFORMATION: {
        SERVICE: 'f000180a-0451-4000-b000-000000000000',
        SYSTEM_ID: 'f0002a23-0451-4000-b000-000000000000',
        MODEL_NUMBER: 'f0002a24-0451-4000-b000-000000000000',
        SERIAL_NUMBER: 'f0002a25-0451-4000-b000-000000000000',
        FIRMWARE_REV: 'f0002a26-0451-4000-b000-000000000000',
        HARDWARE_REV: 'f0002a27-0451-4000-b000-000000000000',
        SOFTWARE_REV: 'f0002a28-0451-4000-b000-000000000000',
        MANIFACTURER: 'f0002a29-0451-4000-b000-000000000000',
        IEEE11073: 'f0002a2a-0451-4000-b000-000000000000',
        PNP_ID: 'f0002a50-0451-4000-b000-000000000000'
    },
    BATTERY: {
        SERVICE: 'f000180f-0451-4000-b000-000000000000',
        LEVEL: 'f0002a19-0451-4000-b000-000000000000'
    },
    TEMPERATURE: {
        SERVICE: 'f000aa00-0451-4000-b000-000000000000',
        DATA: 'f000aa01-0451-4000-b000-000000000000',
        CONFIGURATION: 'f000aa02-0451-4000-b000-000000000000',
        PERIOD: 'f000aa03-0451-4000-b000-000000000000'
    },
    HUMIDITY: {
        SERVICE: 'f000aa20-0451-4000-b000-000000000000',
        DATA: 'f000aa21-0451-4000-b000-000000000000',
        CONFIGURATION: 'f000aa22-0451-4000-b000-000000000000',
        PERIOD: 'f000aa23-0451-4000-b000-000000000000'
    },
    BAROMETER: {
        SERVICE: 'f000aa40-0451-4000-b000-000000000000',
        DATA: 'f000aa41-0451-4000-b000-000000000000',
        CONFIGURATION: 'f000aa42-0451-4000-b000-000000000000',
        PERIOD: 'f000aa44-0451-4000-b000-000000000000'
    },
    // service not available in model CC2650
    // ACCELEROMETER : {
    //   SERVICE :                 'f000aa10-0451-4000-b000-000000000000',
    //   DATA :                    'f000aa11-0451-4000-b000-000000000000',
    //   CONFIGURATION :           'f000aa12-0451-4000-b000-000000000000',
    //   PERIOD :                  'f000aa13-0451-4000-b000-000000000000'
    // },
    // service not available in model CC2650
    // MAGNETOMETER : {
    //   SERVICE :                 'f000aa30-0451-4000-b000-000000000000',
    //   DATA :                    'f000aa31-0451-4000-b000-000000000000',
    //   CONFIGURATION :           'f000aa32-0451-4000-b000-000000000000',
    //   PERIOD :                  'f000aa33-0451-4000-b000-000000000000'
    // },
    // service not available in model CC2650
    // GYROSCOPE : {
    //   SERVICE :                 'f000aa50-0451-4000-b000-000000000000',
    //   DATA :                    'f000aa51-0451-4000-b000-000000000000',
    //   CONFIGURATION :           'f000aa52-0451-4000-b000-000000000000',
    //   PERIOD :                  'f000aa53-0451-4000-b000-000000000000'
    // },
    MOVEMENT: {
        SERVICE: 'f000aa80-0451-4000-b000-000000000000',
        DATA: 'f000aa81-0451-4000-b000-000000000000',
        CONFIGURATION: 'f000aa82-0451-4000-b000-000000000000',
        PERIOD: 'f000aa83-0451-4000-b000-000000000000'
    },
    LIGHT: {
        SERVICE: 'f000aa70-0451-4000-b000-000000000000',
        DATA: 'f000aa71-0451-4000-b000-000000000000',
        CONFIGURATION: 'f000aa72-0451-4000-b000-000000000000',
        PERIOD: 'f000aa73-0451-4000-b000-000000000000'
    },
    KEYPRESS: {
        SERVICE: 'f000ffe0-0451-4000-b000-000000000000',
        STATE: 'f000ffe1-0451-4000-b000-000000000000'
    },
    __REGISTER__: {
        SERVICE: 'f000ac00-0451-4000-b000-000000000000',
        DATA: 'f000ac01-0451-4000-b000-000000000000',
        ADDRESS: 'f000ac02-0451-4000-b000-000000000000',
        DEVICE_ID: 'f000ac03-0451-4000-b000-000000000000'
    },
    CONTROL: {
        SERVICE: 'f000ccc0-0451-4000-b000-000000000000',
        CURRENT_USED_PARAMETERS: 'f000ccc1-0451-4000-b000-000000000000',
        REQUEST_NEW_PARAMETERS: 'f000ccc2-0451-4000-b000-000000000000',
        DISCONNECT_REQUEST: 'f000ccc3-0451-4000-b000-000000000000'
    },
    OAD: {
        SERVICE: 'f000ffc0-0451-4000-b000-000000000000',
        IMAGE_NOTIFY: 'f000ffc1-0451-4000-b000-000000000000',
        IMAGE_BLOCK_REQUEST: 'f000ffc2-0451-4000-b000-000000000000',
        IMAGE_COUNT: 'f000ffc3-0451-4000-b000-000000000000',
        IMAGE_STATUS: 'f000ffc4-0451-4000-b000-000000000000'
    },
    IO: {
        SERVICE: 'f000aa64-0451-4000-b000-000000000000',
        DATA: 'f000aa65-0451-4000-b000-000000000000',
        CONFIG: 'f000aa66-0451-4000-b000-000000000000'
    }
};
const ɵ0 = /**
 * @param {?} key
 * @return {?}
 */
key => TiTag[key].SERVICE;
/** @type {?} */
const TI_SENSORAG_SERVICES = Object.keys(TiTag).map((ɵ0));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lang/uuids/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: manekinekko-angular-web-bluetooth.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BluetoothCore, BrowserWebBluetooth, ConsoleLoggerService, NoLoggerService, ServerWebBluetooth, TI_SENSORAG_SERVICES, TiTag, WebBluetoothModule, browserWebBluetooth, consoleLoggerServiceConfig, makeMeTokenInjector };
//# sourceMappingURL=manekinekko-angular-web-bluetooth.js.map
